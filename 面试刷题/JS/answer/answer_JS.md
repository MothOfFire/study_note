# 回答 JavaScript 的面试题

## 1. 说说 Javascript 中的数据类型？区别？

- JS 中有六种简单数据类型：undefined、null、boolean、string、number、symbol，以及引用类型：object；简单类型是栈内存，值引用，而引用类型是堆内存，地址引用

- 我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型；虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制

- 类型转换：

  - 隐式转换（自动转换）：

    - 隐式转换的场景：比较运算（==、!=、>、<）、if、while 需要布尔值地方；算术运算（+、-、\*、/、%），且要求运算符两边的操作数不是同一类型

    - 自动转换为布尔值：undefined、null、false、+0、-0、NaN、"" 会被转化成 false，其他都换被转化成 true

    - 自动转换为字符串：遇到预期为字符串的地方，就会将非字符串的值自动转为字符串；规则是先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串；常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作

    - 自动转换为数字：除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值；null 转为数值时，值为 0 。undefined 转为数值时，值为 NaN

  - 显式转换（强制转换）：

    - Number()
    - parseInt()
    - String()
    - Object.prototype.toString()
    - Boolean()
    - parseFloat()
    - Math.floor()
    - Math.round()
    - Math.ceil()
    - BigInt()
    - 特殊情况：`undefined == null`为 false 并不是简单的使用 Boolean；`NaN === a(a为变量)`始终为 false，应使用`typeof a === 'number' && isNaN(a)`

## 2. Javscript 数组的常用方法有哪些？

- 操作方法：

  - 增：push()、unshift()、splice()对原数组产生影响；concat() 不会对原数组产生影响

    - push()：在数组末尾添加一个或多个元素，并返回新的长度

    - unshift()：在数组开头添加一个或多个元素，并返回新的长度

    - splice()：传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组

    - concat()：首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组

  - 删：pop()、shift()、splice()对原数组产生影响；slice() 不会对原数组产生影响

    - pop()：用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项

    - shift()：用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项

    - splice()：传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组

    - slice()：用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

  - 改：

    - splice()：传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响

  - 查：

    - indexOf()：从数组前端向末尾开始搜索，返回要查找的元素在数组中的位置，如果没找到则返回-1

    - lastIndexOf()：从数组末尾向前开始搜索，返回要查找的元素在数组中的位置，如果没找到则返回-1

    - includes()：返回要查找的元素在数组中的位置，找到返回 true，否则 false

    - find()：返回第一个匹配的元素

- 排序方法：

  - sort()：接收一个比较函数，用于判断哪个值应该排在前面，如果不传，则会将数组元素先转换为字符串，然后比较它们的 UTF-16 代码单元值

  - reverse()：将数组元素位置颠倒，并返回该数组

- 转换方法：

  - join()：收一个参数，即字符串分隔符，返回包含所有项的字符串

- 迭代方法：

  - map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组

  - forEach()：对数组每一项都运行传入的函数，没有返回值

  - filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回

  - every()：对数组每一项都运行传入的函数，如果对每一项函数返回 true 则返回 true，否则返回 false

  - some()：对数组每一项都运行传入的函数，如果有一项函数返回 true 则返回 true，否则返回 false

## 3. Javascript 字符串的常用方法有哪些？

- 操作方法：

  - 增：增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作

    - concat()：用于连接两个或更多的字符串，返回连接后的字符串

  - 删：slice()、substr()、substring() 都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。

    - slice()：用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

    - substr()：用于创建一个包含原有字符串中一个或多个字符的新字符串，不会影响原始字符串

    - substring()：用于创建一个包含原有字符串中一个或多个字符的新字符串，不会影响原始字符串

  - 改：

    - trim()、trimLeft()、trimRight()：删除前、后或前后所有空格符，再返回新的字符串

    - repeat()：接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果

    - padEnd()：复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件

    - toLowerCase()、 toUpperCase()：大小写转化

  - 查：

    - charAt()：返回给定索引位置的字符，由传给方法的整数参数指定

    - indexOf()：从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）

    - startWith()、includes()：从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

- 转换方法：

  - split()：把字符串按照指定的分割符，拆分成数组中的每一项

- 模板匹配方法：

  - match()：接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象，返回数组

  - search()：接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象，找到则返回匹配索引，否则返回 -1

  - replace()：接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）

## 4. 谈谈 Javascript 中的类型转换机制

- 类型转换：

  - 隐式转换（自动转换）：

    - 隐式转换的场景：比较运算（==、!=、>、<）、if、while 需要布尔值地方；算术运算（+、-、\*、/、%），且要求运算符两边的操作数不是同一类型

    - 自动转换为布尔值：undefined、null、false、+0、-0、NaN、"" 会被转化成 false，其他都换被转化成 true

    - 自动转换为字符串：遇到预期为字符串的地方，就会将非字符串的值自动转为字符串；规则是先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串；常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作

    - 自动转换为数字：除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值；null 转为数值时，值为 0 。undefined 转为数值时，值为 NaN

  - 显式转换（强制转换）：

    - Number()
    - parseInt()
    - String()
    - Object.prototype.toString()
    - Boolean()
    - parseFloat()
    - Math.floor()
    - Math.round()
    - Math.ceil()
    - BigInt()
    - 特殊情况：`undefined == null`为 false 并不是简单的使用 Boolean；`NaN === a(a为变量)`始终为 false，应使用`typeof a === 'number' && isNaN(a)`

## 5. == 和 ===区别，分别在什么情况使用？

- ==：

  - 等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true

  - 在 JavaScript 中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等。遵循以下规则：

    - 如果任一操作数是布尔值，则将其转换为数值再比较是否相等

    - 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等

    - 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法取得其原始值，再根据前面的规则进行比较

    - null 和 undefined 相等

    - 如果有任一操作数是 NaN ，则相等操作符返回 false

    - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true

  - 总结：两个都为简单类型，字符串和布尔值都会转换成数值，再比较；简单类型与引用类型比较，对象转化成其原始类型的值，再比较；两个都为引用类型，则比较它们是否指向同一个对象；null 和 undefined 相等；存在 NaN 则返回 false

- 全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同

  - undefined 和 null 与自身严格相等

- 区别：

  - 相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

  - null 和 undefined 比较，相等操作符（==）为 true，全等为 false

## 6. 深拷贝浅拷贝的区别？如何实现一个深拷贝？

- 数据类型存储：

  - JavaScript 中存在两大数据类型：基本类型、引用类型

  - 基本类型：基本类型数据保存在在栈内存中，值保存在变量中

  - 引用类型：引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中，值保存在内存地址中

- 浅拷贝：指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝；如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址，即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址

  - 在 JavaScript 中，存在浅拷贝的现象有：Object.assign；Array.prototype.slice(), Array.prototype.concat()；使用拓展运算符实现的复制

- 深拷贝：深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

  - 常见的深拷贝方法：\_.cloneDeep()、jQuery.extend()、JSON.stringify()、手写循环递归

- 区别：

  - 浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样；浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象

  - 前提为拷贝类型为引用类型的情况下：浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址；深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址
